============================ESP32===================

IR and PIR:
---------------
int IRSensor=2;
int MotionSensor = 27;
const int LED = 6;
int LEDstate = low;
int Pinstatecurrent = low;
int Pinstateprevious = low;
void setup(){
pinMode (LED,OUTPUT);
pinMode (IRSENSOR,INPUT);
pinMode (MotionSensor ,INPUT);
}
void loop{
Pinstateprevious = Pinstatecurrent;
Pinstatecurrent = digitalRead(MotionSensor);
if(Pinstatecurrent == HIGH && Pinstateprevious == LOW ){
Serial.println("Motion Detected");
int statussensor = digitalRead(IRsensor);
delay(250);
if(statusSensor==1){
digitalWrite(LED,1000);
Serial.println("Person detected but height not matched");
}
else{
digitalWrite(LED,HIGH);
Serial.println("Person detected and height matched");
}}
if(Pinstateprevious ==Pinstatecurrent){
Serial.println("No Motion Detected");
digitalWrite(LED,Low);
}
}

************************************************************************

DHT:
------
#include "DHT.h"

#define DHTPIN 4     // Digital pin connected to the DHT sensor
// Feather HUZZAH ESP8266 note: use pins 3, 4, 5, 12, 13 or 14 --
// Pin 15 can work but DHT must be disconnected during program upload.

// Uncomment whatever type you're using!
//#define DHTTYPE DHT11   // DHT 11
#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321
//#define DHTTYPE DHT21   // DHT 21 (AM2301)

// Connect pin 1 (on the left) of the sensor to +5V
// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1
// to 3.3V instead of 5V!
// Connect pin 2 of the sensor to whatever your DHTPIN is
// Connect pin 4 (on the right) of the sensor to GROUND
// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor

// Initialize DHT sensor.
// Note that older versions of this library took an optional third parameter to
// tweak the timings for faster processors.  This parameter is no longer needed
// as the current DHT reading algorithm adjusts itself to work on faster procs.
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(9600);
  Serial.println(F("DHTxx test!"));

  dht.begin();
}

void loop() {
  // Wait a few seconds between measurements.
  delay(2000);

  // Reading temperature or humidity takes about 250 milliseconds!
  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)
  float h = dht.readHumidity();
  // Read temperature as Celsius (the default)
  float t = dht.readTemperature();
  // Read temperature as Fahrenheit (isFahrenheit = true)
  float f = dht.readTemperature(true);

  // Check if any reads failed and exit early (to try again).
  if (isnan(h) || isnan(t) || isnan(f)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    return;
  }

  // Compute heat index in Fahrenheit (the default)
  float hif = dht.computeHeatIndex(f, h);
  // Compute heat index in Celsius (isFahreheit = false)
  float hic = dht.computeHeatIndex(t, h, false);

  Serial.print(F("Humidity: "));
  Serial.print(h);
  Serial.print(F("%  Temperature: "));
  Serial.print(t);
  Serial.print(F("°C "));
  Serial.print(f);
  Serial.print(F("°F  Heat index: "));
  Serial.print(hic);
  Serial.print(F("°C "));
  Serial.print(hif);
  Serial.println(F("°F"));
}

***************************************************************************
LM35:
---------
#define ADC_VREF_mV    3300.0 // in millivolt
#define ADC_RESOLUTION 4096.0
#define PIN_LM35       36 // ESP32 pin GIOP36 (ADC0) connected to LM35

void setup() {
  Serial.begin(9600);
}

void loop() {
  // read the ADC value from the temperature sensor
  int adcVal = analogRead(PIN_LM35);
  // convert the ADC value to voltage in millivolt
  float milliVolt = adcVal * (ADC_VREF_mV / ADC_RESOLUTION);
  // convert the voltage to the temperature in °C
  float tempC = milliVolt / 10;
  // convert the °C to °F
  float tempF = tempC * 9 / 5 + 32;

  // print the temperature in the Serial Monitor:
  Serial.print("Temperature: ");
  Serial.print(tempC);   // print the temperature in °C
  Serial.print("°C");
  Serial.print("  ~  "); // separator between °C and °F
  Serial.print(tempF);   // print the temperature in °F
  Serial.println("°F");

  delay(500);
}
*************************************************************
LIGHT SENSOR:
-------------
#define LIGHT_SENSOR_PIN 36 // ESP32 pin GIOP36 (ADC0)

void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
}

void loop() {
  // reads the input on analog pin (value between 0 and 4095)
  int analogValue = analogRead(LIGHT_SENSOR_PIN);

  Serial.print("Analog Value = ");
  Serial.print(analogValue);   // the raw analog reading

  // We'll have a few threshholds, qualitatively determined
  if (analogValue < 40) {
    Serial.println(" => Dark");
  } else if (analogValue < 800) {
    Serial.println(" => Dim");
  } else if (analogValue < 2000) {
    Serial.println(" => Light");
  } else if (analogValue < 3200) {
    Serial.println(" => Bright");
  } else {
    Serial.println(" => Very bright");
  }

  delay(500);
}
*************************************************************
potentiometer:
-------------


#define POTENTIOMETER_PIN 36 // ESP32 pin GIOP36 (ADC0) connected to Potentiometer pin
#define LED_PIN           21 // ESP32 pin GIOP21 connected to LED's pin
#define ANALOG_THRESHOLD  1000

void setup() {
  pinMode(LED_PIN, OUTPUT); // set ESP32 pin to output mode
}

void loop() {
  int analogValue = analogRead(POTENTIOMETER_PIN); // read the input on analog pin

  if (analogValue > ANALOG_THRESHOLD)
    digitalWrite(LED_PIN, HIGH); // turn on LED
  else
    digitalWrite(LED_PIN, LOW);  // turn off LED
}

************************************************************
=========================PI==========================
LED Blinking:
------------

import RPi.GPIO as GPIO 
from time import sleep 
GPIO.setwarnings(False) 
GPIO.setmode(GPIO.BOARD) 
GPIO.setup(11, GPIO.OUT, initial=GPIO.LOW) 
while True: 
 GPIO.output(11, GPIO.HIGH) 
 sleep(1) 
 GPIO.output(11, GPIO.LOW) 
 sleep(1) 

****************************************************************************


LED ON_OFF Serial Display:
-------------------------


import RPi.GPIO as GPIO
import time

LED_PIN = 17 


GPIO.setwarnings(False) 


GPIO.setmode(GPIO.BCM) 


GPIO.setup(LED_PIN, GPIO.OUT)

try:
    while True:
        
        GPIO.output(LED_PIN, GPIO.HIGH)
        print("LED ON")
        time.sleep(1)  

        
        GPIO.output(LED_PIN, GPIO.LOW)
        print("LED OFF")
        time.sleep(1)  

except KeyboardInterrupt:
    
    GPIO.cleanup()
    print("Program terminated and GPIO cleaned up.")


**************************************************************************

Pi Camera Enter the number of Picture to take options:
-----------------------------------------------------

from picamera2 import Picamera2, Preview
from time import sleep
from libcamera import Transform

picam2 = Picamera2()


no = int(input("Enter the number of photos to take :"))

picam2.start_preview(Preview.QTGL, transform=Transform(hflip=True, vflip=True))

picam2.start()
for i in range(1,no+1):
    
    picam2.start_and_capture_file(f"/home/project/Pictures/new_image_{i}.jpg")
    sleep(2)
picam2.stop_preview()
picam2.close()


*************************************************************************
Pi Camera take Picture:
----------------------


import time
from picamera2 import Picamera2, Preview
picam = Picamera2()
config = picam.create_preview_configuration()
picam.configure(config)
picam.start_preview(Preview.QTGL)
picam.start()
time.sleep(2)
picam.capture_file("test-python.jpg")
picam.close()


****************************************************************************
Pi Camera take Video:
--------------------

from libcamera import Transform
from picamera2 import Picamera2, Preview
from picamera2.encoders import H264Encoder
import RPi.GPIO as GPIO
from time import sleep

picam2 = Picamera2()
sensorpin=11
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BOARD)
GPIO.setup(sensorpin,GPIO.IN)
video_config = picam2.create_video_configuration()
picam2.configure(video_config)


while True:
    if GPIO.input(sensorpin) == 0:
        encoder = H264Encoder(10000000)
        picam2.start_preview(Preview.QTGL, transform=Transform(hflip=True, vflip=True))
        picam2.start_recording(encoder, 'myvideo.h264')
        sleep(5)
        picam2.stop_recording()
        picam2.stop_preview()
        
    else:
        print('No object detected')
    sleep(2)


*******************************************************************************

IR Camera take Picture:
----------------------

from picamera2 import Picamera2, Preview
from time import sleep
from libcamera import Transform
import RPi.GPIO as GPIO

picam2 = Picamera2()
sensorpin=11
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BOARD)
GPIO.setup(sensorpin,GPIO.IN)
while True:
    if GPIO.input(sensorpin) == 0:
        picam2.start_preview(Preview.QTGL, transform=Transform(hflip=True, vflip=True))
        picam2.start()
        picam2.start_and_capture_file(f"/home/project/Pictures/ir_cap_img.jpg")
        sleep(2)
        picam2.stop_preview()
        picam2.stop()
        
    else:
        print('No object detected')
    sleep(2)



************************************************************************************

IR Sensor with take Video:
-------------------------


from libcamera import Transform
from picamera2 import Picamera2, Preview
from picamera2.encoders import H264Encoder
import RPi.GPIO as GPIO
from time import sleep

picam2 = Picamera2()
sensorpin=11
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BOARD)
GPIO.setup(sensorpin,GPIO.IN)
video_config = picam2.create_video_configuration()
picam2.configure(video_config)


while True:
    if GPIO.input(sensorpin) == 0:
        encoder = H264Encoder(10000000)
        picam2.start_preview(Preview.QTGL, transform=Transform(hflip=True, vflip=True))
        picam2.start_recording(encoder, 'myvideo.h264')
        sleep(5)
        picam2.stop_recording()
        picam2.stop_preview()
        
    else:
        print('No object detected')
    sleep(2)



***********************************************************************************
IR Sensor with LED On_Off:
-------------------------


import RPi.GPIO as IO
import time
IO.setwarnings(False)
IO.setmode(IO.BCM)

IO.setup(18,IO.OUT) #GPIO 3 -> Green LED as output
IO.setup(17,IO.IN) #GPIO 14 -> IR sensor as input
while 1:
    if(IO.input(17)==True): #object is far away
        
        IO.output(18,False) # Green led OFF
    if(IO.input(17)==False): #object is near
        IO.output(18,True) #Green led ON
        

**************************************************************************************

Install adafruit-circuitpython-dht 11 & 22:
------------------------------------------


>>>python3 -m venv VE1

>>>source VE1/bin/activate


>>>python3 -m pip install adafruit-circuitpython-dht


pip install RPi.GPIO  (for Linux os all)

sudo apt-get install libgpiod2   (for linux os 11 only)



>>>python3 dht11.py


By Using Run from Terminal with source path

(VE1) pi@raspi:~/Downloads $ python dht11.py


PIN CONFIG:

PIN 2 VCC
PIN 6 GND
PIN 11 DATA PIN




DHT 11 Temperature & Humidity Sensor Py Code:
--------------------------------------------


import time
import adafruit_dht
import board

dht_device = adafruit_dht.DHT11(board.D17)

while True:
    try:
        temperature_c = dht_device.temperature
        temperature_f = temperature_c * (9 / 5) + 32

        humidity = dht_device.humidity

        print("Temp:{:.1f} C / {:.1f} F    Humidity: {}%".format(temperature_c, temperature_f, humidity))
    except RuntimeError as err:
        print(err.args[0])		

    time.sleep(2.0)



***************************************************************************************


DHT 22 Temperature & Humidity Sensor Py Code:
--------------------------------------------


import time
import adafruit_dht
import board

dht_device = adafruit_dht.DHT22(board.D17)

while True:
    try:
        temperature_c = dht_device.temperature
        temperature_f = temperature_c * (9 / 5) + 32

        humidity = dht_device.humidity

        print("Temp:{:.1f} C / {:.1f} F    Humidity: {}%".format(temperature_c, temperature_f, humidity))
    except RuntimeError as err:
        print(err.args[0])		

    time.sleep(2.0)


***************************************************************************************

LDR Sensor for Py Code:
----------------------


# Example Code: Interfacing LDR with Raspberry Pi
# Iotbyhvm.ooo - Explore TechBytes

import RPi.GPIO as GPIO
import time

GPIO.setmode(GPIO.BCM)

# Pin Definitions
ldr_threshold = 1000
LDR_PIN = 18
LIGHT_PIN = 11

def readLDR(PIN):
    reading = 0
    GPIO.setup(LDR_PIN, GPIO.OUT)
    GPIO.output(LDR_PIN, False)
    time.sleep(0.1)
    GPIO.setup(LDR_PIN, GPIO.IN)

    # Count until pin reads HIGH
    while not GPIO.input(LDR_PIN):
        reading += 1

    return reading

def switchOnLight(PIN):
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, True)

def switchOffLight(PIN):
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, False)

# Main Loop
try:
    while True:
        ldr_reading = readLDR(LDR_PIN)
        print(f"LDR Reading: {ldr_reading}")

        if ldr_reading < ldr_threshold:
            switchOnLight(LIGHT_PIN)
        else:
            switchOffLight(LIGHT_PIN)

        time.sleep(1)
except KeyboardInterrupt:
    GPIO.cleanup()  # Clean up GPIO pins on exit


*************************************************************************************


MQTT Pi & ESP2 :
---------------

MQTT Between Pi and ESP32


Raspberry Pi :


Run the following commands : 
* Open a terminal and run : 
ifconfig
* Note the ip address in wlan0 section (Eg 172.168.134.35)
* sudo apt install mosquitto mosquitto-clients
* sudo systemctl status mosquito
* sudo systemctl enable mosquitto.service
* sudo nano /etc/mosquitto/mosquitto.conf
(Open the File and add the below content to the last line)
listener 1883
allow_anonymous true

* Install paho package by the command : sudo apt install python3-paho-mqtt
* The code to be run in Raspberry Pi is given below:

Python Code in Pi:
-----------------


import paho.mqtt.client as mqtt

broker_address="192.168.173.114" // ip of the mobile device we noted from ifconfig command
client=mqtt.Client("PiClient")
client.connect(broker_address)

def on_message(client,userdata,message):
    print("Message received"+message.payload.decode("utf-8"))
    client.publish("ESP32/Acknowledgement","Message received from from ESP32, sent from Pi")

client.on_message=on_message
client.subscribe("ESP32/Temperaturedataread")
client.loop_start()
while True:
    pass



Run the code using the run button in thonny, no need cli commands.

In ESP32 :
----------

1. Copy and paste the ESP32 Code into the IDE 
2. Change the wifi SSID and Password with the name of your wifi and password(hotspot)
3. Replace the ip address in the code with the ip address noted before
4. Ensure that PubSubClient.h package is installed else install it in arduino IDE
5. Upload the code into ESP32


Once the ESP32 is connected to the network and successfully connected to the MQTT Client 
In Raspberry pi , Run the following commands in a terminal : 

#no need to use this cli command, we have written a py script to subscribe and publish
To visualize the data arrived at RPI Broker, execute the below command
mosquitto_sub -d -t ESP32/Temperaturedataread


In the terminal you can see a message being transmitted and acknowledgement being received.


Modified ESP 32 Code : 
#include <WiFi.h>
#include <PubSubClient.h>

#define Ledpin 13
#define IRpin 14

// WIFI credentials
const char* ssid = "ssid";
const char* password = "password";

// MQTT Broker IP address
const char* mqtt_server = "192.168.173.114";

char tempString[20];  // Buffer to hold the message
WiFiClient espClient;
PubSubClient client(espClient);

// Callback function when a message is received
void callback(char* topic, byte* message, unsigned int length) {
  Serial.print("Message arrived on topic: ");
  Serial.println(topic);
  
  // Create a temporary string to hold the message
  String messageTemp;
  for (int i = 0; i < length; i++) {
    messageTemp += (char)message[i];
  }

  Serial.print("Message: ");
  Serial.println(messageTemp);

  // Check if the received topic is the acknowledgment topic
  if (String(topic) == "ESP32/Acknowledgement") {
    Serial.println("Acknowledgment received from Raspberry Pi!");
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(Ledpin, OUTPUT);
  pinMode(IRpin, INPUT);

  // Connect to WiFi
  Serial.println("Connecting to WiFi");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected to WiFi with IP: ");
  Serial.println(WiFi.localIP());

  // Setup MQTT client and set callback
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);

  // Connect to the MQTT broker
  while (!client.connected()) {
    Serial.println("Connecting to MQTT...");
    if (client.connect("espClient")) {
      Serial.println("Connected to MQTT broker");
      client.subscribe("ESP32/Acknowledgement");  // Subscribe to acknowledgment topic
    } else {
      Serial.print("Failed to connect, state: ");
      Serial.println(client.state());
      delay(2000);
    }
  }
}

void loop() {
  // Ensure the MQTT client stays connected and processes incoming messages
  client.loop();

  bool IRstatus = digitalRead(IRpin);
  if (IRstatus == true) {
    digitalWrite(Ledpin, LOW);  // Turn off the LED
    strcpy(tempString, "LED OFF");
  } else {
    digitalWrite(Ledpin, HIGH);  // Turn on the LED
    strcpy(tempString, "LED ON");
  }

  // Publish the status to the MQTT topic
  client.publish("ESP32/Temperaturedataread", tempString);


  delay(2000);
}


*************************************************************************************

Web Browser for ESP32 Code:
---------------------------

#include <WiFi.h>
#include <HTTPClient.h>
const char* ssid = "wifi_name";
const char* password = "pswd";
void setup() {
Serial.begin(115200);
WiFi.begin(ssid, password);
Serial.println("Connecting");
while(WiFi.status() != WL_CONNECTED) {
delay(500);
Serial.print(".");
}
Serial.println("");
Serial.print("Connected to WiFi network with IP Address: ");
Serial.println(WiFi.localIP());
Serial.println("Timer set to 5 seconds (timerDelay variable), it will take 5 seconds before publishing the first reading.");
}
void loop() {
if(WiFi.status()== WL_CONNECTED){
HTTPClient http;
http.begin("http://192.168.243.153:8000/get-sensor?temperature=243");
int httpCode = http.GET();
if (httpCode > 0) { 
String payload = http.getString();
Serial.println(httpCode);
Serial.println(payload);
}
else {
Serial.println("Error on HTTP request");
}
http.end();
}else{
}
delay(10000);
}




Pi code for Web Browser:  (app.py)
-----------------------


from flask import Flask, request


app = Flask(__name__)
l = []


@app.route('/')
def index():
    return 'OK', 200


@app.route('/get-sensor', methods=['GET'])
def data():
    if request.method == 'GET':
        args = request.args
        temperature = args.get('temperature')
        l.append(temperature)
        return temperature
    else:
        return 'Wrong'


@app.route('/get')
def data1():
    sensor_data = '<ul>'
    for item in l:
        sensor_data += f'<li>{item}</li>'
    sensor_data += '</ul>'
    return sensor_data


if __name__ == '__main__':
    app.run(debug=True, port=8000, host='0.0.0.0')


*********************************************************************************

i 2 c for Py Code:
-----------------


# Raspberry Pi Master for Arduino Slave
from smbus import SMBus
addr = 0x8 # bus address
bus = SMBus(1)
numb = 1
print ("Enter 1 for ON or 0 for OFF")
while numb == 1:
ledstate = input(">>>> ")
if ledstate == "1":
bus.write_byte(addr, 0x1) # switch it on
elif ledstate == "0":
bus.write_byte(addr, 0x0) # switch it off
else:
numb = 0


i 2 c for Arduino Uno Code:
--------------------------


// Include the Wire library for I2C
#include <Wire.h>
  const int ledPin = 13;
  void setup() 
  {
    Wire.begin(0x8);
    Wire.onReceive(receiveEvent);
    pinMode(ledPin, OUTPUT);
    digitalWrite(ledPin, LOW);
  }
// Function that executes whenever data is received from master
    void receiveEvent(int n) 
  {
    while (Wire.available()) 
    { // loop through all but the last
    char c = Wire.read(); // receive byte as a character
    digitalWrite(ledPin, c);
  }
}
  void loop() 
  {
    
    delay(100);
}

=============================thing speak========================================
----------dht sensor------------

#include <WiFi.h>
#include "ThingSpeak.h"
#include “DHT.h”
#define DHTPIN 4
#define DHTTYPE DHT11 // DHT11 or DHT22
DHT dht(DHTPIN, DHTTYPE);
const char* ssid = "REPLACE_WITH_YOUR_SSID"; // your network SSID (name)
const char* password = "REPLACE_WITH_YOUR_PASSWORD"; // your network password
WiFiClient client;
unsigned long myChannelNumber = xxxx; // channel number shown in private window tab
const char * myWriteAPIKey = "XXXXXXXXXXXXXXXX";
// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 30000;
// Variable to hold temperature readings
float tempC,humidity;
void setup()
{
pinmode (DHTPIN,INPUT);
Serial.begin(115200); //Initialize serial
WiFi.mode(WIFI_STA);
ThingSpeak.begin(client); // Initialize ThingSpeak
}
void loop() {
if ((millis() - lastTime) > timerDelay)
{
// Connect or reconnect to WiFi
if(WiFi.status() != WL_CONNECTED){
Serial.print("Attempting to connect");
while(WiFi.status() != WL_CONNECTED){
WiFi.begin(ssid, password);
delay(5000);
}
Serial.println("\nConnected.");
}
// Get a new temperature reading
float tempC =dht.readTemperature();
float humidity = dht.readHumidity();
Serial.print("Temperature (oC): ");
Serial.println(tempC);
Serial.print("Humidity (%): ");
Serial.println(humidity);
// set the fields with the values
ThingSpeak.setField(1, temperatureC);
ThingSpeak.setField(2, humidity);
// Write to ThingSpeak. There are up to 8 fields in a channel, allowing the user to store up to 8
different pieces of information in a channel.
int x = ThingSpeak.writeField(myChannelNumber, myWriteAPIKey);
//To write to ThingSpeak , use the writeField() method that accepts the following arguments : (a)
the channel number (b) the field number (in our case, there is only one field) (c) the value to be
published (temperatureC) and (d) the write API key.This function returns the code 200 if it has
succeeded in publishing the readings //
if(x == 200)
{
Serial.println("Channel update successful.");

}
else
{
Serial.println("Problem updating channel. HTTP error code " + String(x));
}
lastTime = millis();
}
}

-----------------lm35 sensor----------------
#include <WiFi.h>
#include "ThingSpeak.h"
#define ADC_VREF_mV 3300.0 // in millivolt
#define ADC_RESOLUTION 4096.0
#define PIN_LM35 36 // ESP32 pin GIOP36 (ADC0) connected to LM35
/* #include “DHT.h”
#define DHTPIN 4
#define DHTTYPE DHT11 // DHT11 or DHT22
DHT dht(DHTPIN, DHTTYPE); */ // uncomment these lines if DHT sensor is used
const char* ssid = "REPLACE_WITH_YOUR_SSID"; // your network SSID (name)
const char* password = "REPLACE_WITH_YOUR_PASSWORD"; // your network password
WiFiClient client;
unsigned long myChannelNumber = xxxx; // channel number shown in private window tab
const char * myWriteAPIKey = "XXXXXXXXXXXXXXXX";
// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 30000;
// Variable to hold temperature readings
float tempC;
void setup()
{
pinmode (temppin,INPUT);
Serial.begin(115200); //Initialize serial
WiFi.mode(WIFI_STA);
ThingSpeak.begin(client); // Initialize ThingSpeak
}
void loop() {
if ((millis() - lastTime) > timerDelay)
{
// Connect or reconnect to WiFi
if(WiFi.status() != WL_CONNECTED){
Serial.print("Attempting to connect");
while(WiFi.status() != WL_CONNECTED){
WiFi.begin(ssid, password);
delay(5000);
}
Serial.println("\nConnected.");
}
// Get a new temperature reading
int adcVal = analogRead(PIN_LM35);
// convert the ADC value to voltage in millivolt
float milliVolt = adcVal * (ADC_VREF_mV / ADC_RESOLUTION);
// convert the voltage to the temperature in °C
float tempC = milliVolt / 10;
Serial.print("Temperature (oC): ");
Serial.println(temperatureC);

// Write to ThingSpeak. There are up to 8 fields in a channel, allowing the user to store up to 8
different pieces of information in a channel. Here, the sensor reading is written to field 1.

int x = ThingSpeak.writeField(myChannelNumber, 1, tempC, myWriteAPIKey);

//To write to ThingSpeak , use the writeField() method that accepts the following arguments : (a)
the channel number (b) the field number (in our case, there is only one field) (c) the value to be
published (temperatureC) and (d) the write API key.This function returns the code 200 if it has
succeeded in publishing the readings //

if(x == 200)
{
Serial.println("Channel update successful.");
}
else
{
Serial.println("Problem updating channel. HTTP error code " + String(x));
}
lastTime = millis();
}
}

---------------------------nornmal gcr code----------------------


**************************************************************************************
=====================task scheduling:-=============
#include <Arduino.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
TaskHandle_t xHandle1,xHandle2;
#define rled 4
#define gled 5
void setup() {
pinMode(rled,OUTPUT);
pinMode(gled,OUTPUT);
Serial.begin(9600);
xTaskCreate(taskOne,"TaskOne",10000,NULL,1,&xHandle1);
Serial.println("\ninside setup");
}
void loop() {
delay(1000);
}
void taskOne( void * parameter ){
int i=0;
Serial.println("\nHello from task 1");
while(i<4){
Serial.print("Task 1:");
if(i==2){
xTaskCreate(taskTwo,"TaskTwo",10000,NULL,2,&xHandle2);
}
digitalWrite(rled,HIGH);
digitalWrite(gled,LOW);
Serial.println(i);
vTaskDelay(pdMS_TO_TICKS(5000));
i++;
}
Serial.println("Ending task 1");
vTaskDelete( NULL );
}
void taskTwo( void * parameter){
int i=0;
Serial.println("\nHello from task 2");
while(i<4){
Serial.print("Task 2:");
digitalWrite(gled,HIGH);
digitalWrite(rled,LOW);
Serial.println(i);
vTaskDelay(pdMS_TO_TICKS(1000));
i++;
}
Serial.println("Ending task 2");
vTaskDelete( NULL );
}

=======================mutual exclusion =============================

#include <stdio.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include "freertos/semphr.h"
SemaphoreHandle_t mySemaphore;
void setup() {
  Serial.println("inside setup");
  Serial.begin(9600);
  if ( mySemaphore == NULL ) // Check to confirm that the Serial Semaphore has not already been created.
  {
    mySemaphore = xSemaphoreCreateBinary(); // Create a binary semaphore
    if ( (mySemaphore) != NULL )
    xSemaphoreGive( (mySemaphore) ); // Make the Serial Port available for use, by "Giving" the Semaphore.
  }
  xTaskCreate(TaskLed, "Led", 10000, NULL, 1, NULL );
  xTaskCreate(TaskBlink, "LedBlink", 10000, NULL, 1, NULL );
  digitalWrite(7,LOW);
  digitalWrite(8,LOW);
  }
void loop() {}
void TaskLed(void *pvParameters)
{
  (void) pvParameters;
  Serial.println("inside taskled");
  pinMode(8, OUTPUT);
  for(;;)
  {
    if (xSemaphoreTake(mySemaphore, ( TickType_t ) 10 ) != pdTRUE)
    {
      Serial.println("waiting inside taskled for semaphore");
      digitalWrite(8,LOW);
    }
    else
    {
      Serial.println("semaphore taken inside taskled");
      digitalWrite(8,HIGH);
      delay(5000);
      xSemaphoreGive(mySemaphore);
      Serial.println(" semaphore given by taskled");
      delay(1000);
    }
  }
}
void TaskBlink(void *pvParameters)
{
  (void) pvParameters;
  Serial.println("inside taskblink");
  pinMode(7, OUTPUT);
  for(;;){
    if (xSemaphoreTake(mySemaphore, ( TickType_t ) 10 ) != pdTRUE)
    {
      Serial.println("waiting inside taskblink for semaphore");
      digitalWrite(7,LOW);
    }
    else{
      Serial.println("semaphore taken inside taskblink");
      digitalWrite(7,HIGH);
      delay(5000);
      xSemaphoreGive(mySemaphore);
      Serial.println("semaphore given by taskblink");
      delay(1000);
    }
  }
}

